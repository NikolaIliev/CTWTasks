Built as a Console Application using Visual Studio 2017

Tasks:

1. Job Queue.
Трябва ни клас JobQueue в който да се добавят задачи в опашка и да могат да се вадят същите тези задачи от опашката. За целта на задачата може да приемем, че задачите са числа (int). Тоест класът трябва да има два метода:

void addJob(int job);
int getJob();

Вътрешно може да ползваш стандартна опашка std::queue.
Добавянето на задача - просто я добавя в опашката.
Когато взимаме задача през getJob - функцията трябва да ни върне следващия елемент от опашката. Ако опашката в този момент е празна, функцията getJob трябва да изчака докато се появи задача, която да върне - тоест функцията връща управлението само ако има задача, която да върне.

Основната цел на класа JobQueue е той да бъде ползван в многонишков сценарий. Представи си, че има няколко нишки които произвеждат задачи - тоест извикват addJob паралелно и постоянно. Съответно имаш и няколко нишки - работници - които паралелно и постоянно взимат задачи чрез getJob.

Това е един от най-популярните многонишкови сценарии и patterns. Препоръчително е да ползваш примитивите mutex и condition variable, които в C++ са std::mutex и std::condition_variable. 



2. Combination Generator
Трябва ни клас, който получава vector от обекти (за простота нека са int) в конструктора си:
CombinationGenerator(std::vector<int> elements);

Трябва ни функция:
std::vector<std::vector<int>> generate(size_t k) която генерира всички под множества с k елемента.
Също така класът трябва да вземе впредвид и функция, която проверява съвместимост между елементи:

virtual bool areCompatible(int a, int b);

която трябва да се извика между всеки два елемента от комбинацията и ако те не са съвместими, тази комбинация да не се връща.
Тази функция не е важна каква логика има - класът ти може да бъде наследен и логиката сменена за нуждните на потребителя на класа.

Например ако имлементираме функцията да казва че двата елемента трябва да бъдат с еднаква четност:
CombinationGenerator generator({1, 2, 3, 4, 5, 6});
generator.generate(2);

Това трябва да произведе следните комбинации:
1 3
1 5
3 5
2 4
2 6
4 6

generator.generate(3);
1 3 5
2 4 6

Очаква се, че класът няма да генерира всички комбинациите до край и тогава да провери съвместимостта.
Например: След стигане до комбинация 1 2, няма смисъл да се генерира
1 2 3
1 2 4
1 2 5
1 2 6
Защото още от първите два елемента знаем че всяка комбинация включваща тях ще е невалидна.